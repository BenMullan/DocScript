Namespace Runtime

	''' <summary>Represents the State of one or more SymbolTables at a given point during the execution of a DocScript program</summary>
	Public Class SymbolTablesSnapshot

		Protected SymbolTables_ As List(Of DocScript.Runtime.SymbolTable)

		REM There is no by-design mechanism for ensuring that the same identifier does not appear in multiple SymTbls. This has to be validated by EnsureObjectIsInValidState_().
		''' <summary>
		''' PUBLIC CONSTRUCTOR: Constructs the Snapshot with the specified SymTbls.
		''' The _BottomStack can contain 0 elements, but a _Topmost must be specified, which - in the case of the Program - will be the Global Symbol Table.
		''' Also ensures that no Identifier appears in multiple Symbol Tables.
		''' ----------------------------------------------------------------------------------------------------------
		''' If there are no downstairs SymbolTables, then use [SymbolTablesSnapshot].[Empty] for the _BottomStack Argument.
		''' This is the case in for the GlobalSymbolTable, as Generated by a [Program] Object.
		''' ----------------------------------------------------------------------------------------------------------
		''' </summary>
		Public Sub New(ByVal _BottomStack As SymbolTablesSnapshot, ByVal _Topmost As SymbolTable)
			Me.SymbolTables_ = _BottomStack.SymbolTables_.Concat({_Topmost}).ToList() : EnsureObjectIsInValidState_()
			LogLexingMessage("Instanciated a New SymbolTables Snapshot with " & _BottomStack.SymbolTables_.Count.ToString() & " SymTbls on the BottomStack")
		End Sub

		''' <summary>PROTECTED CONSTRUCTOR: FromSymbolTablesArray</summary>
		Protected Sub New(ByVal _SymTbls As SymbolTable())
			Me.SymbolTables_ = _SymTbls.ToList() : Me.EnsureObjectIsInValidState_()
		End Sub

		''' <summary>Returns all but the Topmost SymbolTable in the current SymTbls' Snapshot</summary>
		Public ReadOnly Property BottomStack As SymbolTablesSnapshot
			Get
				Return (New SymbolTablesSnapshot(Me.SymbolTables_.ToArray().AllButLast())) 'Protected Constructor
			End Get
		End Property

		''' <summary>Returns only the Topmost SymbolTable in the current SymTbls' Snapshot</summary>
		Public Property Topmost As SymbolTable
			Get
				Try
					If Me.SymbolTables_.Count < 1 Then Throw New DSValidationException("The Topmost SymbolTable could not be Returned, because there are fewer than one SymbolTables in the Snapshot", "No. SymTbls: " & Me.SymbolTables_.Count.ToString())
					Return Me.SymbolTables_.Last()
				Catch _Ex As Exception : Throw New DSException("@SymbolTablesSnapshot\Topmost\Get: " & _Ex.Message, _Ex) : End Try
			End Get
			Set(ByVal _NewSymTbl As SymbolTable)
				Try
					Me.SymbolTables_.Item(Me.SymbolTables_.Count - 1) = _NewSymTbl
				Catch _Ex As Exception : Throw New DSException("@SymbolTablesSnapshot\Topmost\Set: " & _Ex.Message, _Ex) : End Try
			End Set
		End Property

		''' <summary>Returns or Sets the Bottommost SymbolTable in the current SymTbls' Snapshot</summary>
		Public Property Bottommost As SymbolTable
			Get
				Try
					If Me.SymbolTables_.Count < 1 Then Throw New DSValidationException("The Bottommost SymbolTable could not be Returned, because there are fewer than one SymbolTables in the Snapshot", "No. SymTbls: " & Me.SymbolTables_.Count.ToString())
					Return Me.SymbolTables_.First()
				Catch _Ex As Exception : Throw New DSException("@SymbolTablesSnapshot\Bottommost\Get: " & _Ex.Message, _Ex) : End Try
			End Get
			Set(ByVal _NewSymTbl As SymbolTable)
				Try
					Me.SymbolTables_.Item(0) = _NewSymTbl
				Catch _Ex As Exception : Throw New DSException("@SymbolTablesSnapshot\Bottommost\Set: " & _Ex.Message, _Ex) : End Try
			End Set
		End Property

		''' <summary>Used by Execution Components, to report how many SymbolTables they have received</summary>
		Public ReadOnly Property InnerSymbolTables_Count As Int32
			Get
				Return Me.SymbolTables_.Count
			End Get
		End Property

		''' <summary>Used for external components who want to e.g. see which entries are visible in the current execution branch</summary>
		Public ReadOnly Property SymbolTables_ReadOnlyCopy As ObjectModel.ReadOnlyCollection(Of Runtime.SymbolTable)
			Get
				Return (New ObjectModel.ReadOnlyCollection(Of SymbolTable)(Me.SymbolTables_))
			End Get
		End Property

		''' <summary>Used for external components who want to e.g. see which entries are visible in the current execution branch</summary>
		Public ReadOnly Property AllEntriesInAllSymbolTables_ReadOnlyCopy As ObjectModel.ReadOnlyCollection(Of KeyValuePair(Of [String], Runtime.SymbolTable.ISymbolTableEntry))
			Get

				Dim _AllEntries As New List(Of KeyValuePair(Of [String], Runtime.SymbolTable.ISymbolTableEntry))()

				For Each _SymTbl As SymbolTable In Me.SymbolTables_ReadOnlyCopy
					For Each _SymTblEntry As KeyValuePair(Of [String], Runtime.SymbolTable.ISymbolTableEntry) In _SymTbl.Entries_ReadOnlyCopy
						_AllEntries.Add(_SymTblEntry)
					Next
				Next

				Return (New ObjectModel.ReadOnlyCollection(Of KeyValuePair(Of [String], Runtime.SymbolTable.ISymbolTableEntry))(_AllEntries.ToList()))

			End Get
		End Property

		''' <summary>Mutates the state of the current Snapshot, to include an Entry for _Entry in the Topmost SymbolTable</summary>
		Public Sub AddEntryToToTopmost(ByVal _Identifier$, ByVal _Entry As SymbolTable.ISymbolTableEntry)
			Try : LogExecutionMessage("Adding SymbolTable Entry for " & _Identifier.InSquares() & " to SymbolTablesSnapshot")

				'The SymTbl's AddEntry() Method will handle the ToUpper()-ing of the Identifier
				'If there exists already a SymbolTableEntry with _Identifer, then SymbolTable.AddEntry() will catch this
				Me.SymbolTables_.Item(Me.SymbolTables_.Count - 1).AddEntry(_Identifier, _Entry)

			Catch _Ex As Exception : Throw New DSException("@SymbolTablesSnapshot\AddEntryToToTopmost: " & _Ex.Message, _Ex) : End Try
		End Sub

		''' <summary>Returns the first Entry whose Identifier is _Identifier, from any of the SymbolTables in the Snapshot</summary>
		Public Function GetEntryFromAny(ByVal _Identifier$) As SymbolTable.ISymbolTableEntry
			Try : LogExecutionMessage("Getting SymbolTable Entry for " & _Identifier.InSquares() & " from SymbolTablesSnapshot")

				Dim _SymTblContainingReleventEntry_Resolver As Func(Of SymbolTable, Boolean) = _
				 Function(_SymTbl As SymbolTable) _SymTbl.Entries_ReadOnlyCopy.GetAllKeys().Contains(_Identifier.ToUpper())

				REM Ensure that at least one SymbolTable contains an Entry with the specified _Identifier
				If Not Me.SymbolTables_.Any(_SymTblContainingReleventEntry_Resolver) Then Throw New [DSNonexistentSymbolException](_Identifier, "No SymbolTable in the Snapshot contained an Entry for the specified Identifier")

				REM Get the Entry from [the First SymTbl to contain the Identifier]
				Dim _SymTblContainingIdentifier As SymbolTable = Me.SymbolTables_.First(predicate:=_SymTblContainingReleventEntry_Resolver)
				LogExecutionMessage("The SymbolTable containing the entry for " & _Identifier.InSquares() & " is " & _SymTblContainingIdentifier.Description.InSquares())
				Return _SymTblContainingIdentifier.GetEntry(_Identifier)

			Catch _Ex As Exception : Throw New DSException("@SymbolTablesSnapshot\GetEntryFromAny: " & _Ex.Message, _Ex) : End Try
		End Function

		''' <summary>Updates the first entry whose Identifier is _Identifier, to have the value _NewValue. This method mutates the state of the current Snapshot.</summary>
		Public Sub UpdateEntryInAny(ByVal _Identifier$, ByVal _NewValue As SymbolTable.ISymbolTableValue)
			Try : LogExecutionMessage("Updating Value of " & _Identifier.InSquares() & " to new value of Type" & _NewValue.GetType().Name.InSquares() & " in SymbolTableSnapshot")

				Dim _SymTblContainingReleventEntry_Resolver_ As Func(Of SymbolTable, Boolean) = _
				 Function(_SymTbl As SymbolTable) _SymTbl.Entries_ReadOnlyCopy.GetAllKeys().Contains(_Identifier.ToUpper())


				REM Ensure that at least one SymbolTable contains an Entry with the specified _Identifier
				If Not Me.SymbolTables_.Any(_SymTblContainingReleventEntry_Resolver_) Then Throw New [DSNonexistentSymbolException](_Identifier, "No SymbolTable in the Snapshot contained an Entry for the specified Identifier")

				REM Update the Entry in the First SymTbl to contain the Identifier
				Me.SymbolTables_.Item(Me.SymbolTables_.ToArray().IndexOfFirstWhere(_SymTblContainingReleventEntry_Resolver_)).UpdateEntry(_Identifier, _NewValue)

			Catch _Ex As Exception : Throw New DSException("@SymbolTablesSnapshot\UpdateEntryInAny: " & _Ex.Message, _Ex) : End Try
		End Sub

		''' <summary>Evaluates weather or not an Entry with _Identifier is contained in any of the SymbolTables in the current Snapshot</summary>
		Public ReadOnly Property IsContainedInAny(ByVal _Identifier$) As Boolean
			Get
				Try : LogExecutionMessage("Checking if SymbolTableSnapshot contains Entry for " & _Identifier.InSquares())

					Dim _SymTblContainingReleventEntry_Resolver_ As Func(Of SymbolTable, Boolean) = _
					   Function(_SymTbl As SymbolTable) _SymTbl.Entries_ReadOnlyCopy.GetAllKeys().Contains(_Identifier.ToUpper())


					REM Ensure that at least one SymbolTable contains an Entry with the specified _Identifier
					Return Me.SymbolTables_.Any(_SymTblContainingReleventEntry_Resolver_)

				Catch _Ex As Exception : Throw New DSException("@SymbolTablesSnapshot\IsContainedInAny: " & _Ex.Message, _Ex) : End Try
			End Get
		End Property

		''' <summary>Evaluates weather or not each SymbolTable in _OtherSymTbls contains the same number of entries, and has the same identifiers and value types, as the SymbolTables in the current instance</summary>
		Public ReadOnly Property AlignsWith(ByVal _OtherSymTbls As SymbolTablesSnapshot) As Boolean
			Get

				LogExecutionMessage("Checking SymbolTablesSnapshot Alignment")

				'There must be the same number of SymTbls in the Argument as in the current Instance
				If Not (Me.SymbolTables_.Count = _OtherSymTbls.SymbolTables_.Count) Then Return False

				'Each SymbolTable must contain the same number of Entries, and must have the same Identifiers; only the Values can be different
				For _SymTblIndex% = 0 To (_OtherSymTbls.SymbolTables_.Count - 1) Step +1
					If Not Me.SymbolTables_.ElementAt(_SymTblIndex).AlignsWith(_OtherSymTbls.SymbolTables_.ElementAt(_SymTblIndex)) Then Return False
				Next

				Return True

			End Get
		End Property

		''' <summary>Ensures that no Identifier appears in multiple SymTbls</summary>
		Protected Sub EnsureObjectIsInValidState_()

			REM Ensure that the same identifier does not appear in multiple SymTbls
			Dim _AllIdentifiers_FromAllSymTbls As New List(Of [String])()
			Me.SymbolTables_.ForEach(Sub(_SymTbl As SymbolTable) _SymTbl.Entries_ReadOnlyCopy.ForEachItem(Sub(_Entry As KeyValuePair(Of [String], SymbolTable.ISymbolTableEntry)) _AllIdentifiers_FromAllSymTbls.Add(_Entry.Key.ToUpper())))

			If Not _AllIdentifiers_FromAllSymTbls.ToArray().AllElementsAreUnique() Then Throw New DSValidationException("At least one Identifier appeared in multiple SymbolTables in the Snapshot", "(The Snapshot's SymbolTables' Identifiers)")

		End Sub

		''' <summary>Creates and Returns a New Snapshot with [Me] and [_NewTopMost]</summary>
		Public ReadOnly Property SnapshotFrom_ThisAndTopmost(ByVal _NewTopmost As SymbolTable) As SymbolTablesSnapshot
			Get
				Return New SymbolTablesSnapshot(Me, _NewTopmost)
			End Get
		End Property

#Region "Serialisation"

		''' <summary>Produces a DS-KVP Human-readable String for the SymTblSnpSht</summary>
		Public Overrides Function ToString() As String
			Return DocScript.Utilities.KVPSerialisation.GetKVPString({"SymbolTablesCount", Me.SymbolTables_.Count.ToString()})
		End Function

		''' <summary>Produces an XML representation of all the SymbolTables in the Snapshot, with all their values and identifiers</summary>
		Public Function ToXML() As XElement

			Dim _XElement As XElement = <SymbolTablesSnapshot/>
			_XElement.Add(Me.SymbolTables_.Select(Of XElement)(Function(_SymTbl As SymbolTable) _SymTbl.ToXML()))
			Return _XElement

		End Function

		''' <summary>Constructs an instance of the class from its XML representation</summary>
		Public Shared Function FromXML(ByVal _XML As XElement) As SymbolTablesSnapshot
			Try
				REM We should have received: <SymbolTablesSnapshot> ...
				Return New SymbolTablesSnapshot(_SymTbls:=_XML.<SymbolTable>.Select(Of SymbolTable)(AddressOf SymbolTable.FromXML).ToArray())
			Catch _Ex As Exception : Throw New DSException("@SymbolTablesSnapshot\FromXML: " & _Ex.Message, _Ex) : End Try
		End Function

#End Region

		''' <summary>Generates a New Empty SymTblsSnpSht</summary>
		Public Shared ReadOnly Property Empty As SymbolTablesSnapshot
			Get
				Return (New SymbolTablesSnapshot({}))
			End Get
		End Property

	End Class

End Namespace